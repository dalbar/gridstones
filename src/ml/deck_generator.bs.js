// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Caml_obj from "./../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "./../../node_modules/bs-platform/lib/es6/belt_List.js";
import * as Belt_Array from "./../../node_modules/bs-platform/lib/es6/belt_Array.js";
import * as Caml_int32 from "./../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Caml_exceptions from "./../../node_modules/bs-platform/lib/es6/caml_exceptions.js";

var DIM = Caml_exceptions.create("Deck_generator.DIM");

function generate_one_stone_permutations(row) {
  var fill_copy = function (idx) {
    var row$1 = row.slice(0);
    Belt_Array.setExn(row$1, idx, 1);
    return row$1;
  };
  var loop = function (perm, idx) {
    try {
      var cur_value = Belt_Array.getExn(row, idx);
      if (cur_value !== -1) {
        return loop(perm, idx + 1 | 0);
      } else {
        return loop(Belt_List.add(perm, fill_copy(idx)), idx + 1 | 0);
      }
    }
    catch (exn){
      return perm;
    }
  };
  return loop(Belt_List.make(0, row), 0);
}

function filter_dups_from_list(perm) {
  var no_dup = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(perm, no_dup, (function (acc, row) {
                if (Belt_List.has(acc, row, (function (l1, l2) {
                          return Belt_Array.eq(l1, l2, Caml_obj.caml_equal);
                        }))) {
                  return acc;
                } else {
                  return Belt_List.add(acc, row);
                }
              }));
}

function generate_row_permutations(size, max_stones) {
  var empty_row = Belt_Array.make(size, -1);
  var res = Belt_List.make(1, empty_row);
  var loop = function (_cur_stones, _latest_rows, _res) {
    while(true) {
      var res = _res;
      var latest_rows = _latest_rows;
      var cur_stones = _cur_stones;
      if (cur_stones > max_stones) {
        return res;
      } else {
        var new_rows = Belt_List.flatten(Belt_List.map(latest_rows, generate_one_stone_permutations));
        _res = Belt_List.concat(res, latest_rows);
        _latest_rows = new_rows;
        _cur_stones = cur_stones + 1 | 0;
        continue ;
      }
    };
  };
  return filter_dups_from_list(loop(0, res, Belt_List.make(-1, empty_row)));
}

function append_matrix(matrix, rows) {
  var res = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(rows, res, (function (acc, row) {
                return Belt_List.add(acc, Belt_Array.concat(matrix, row));
              }));
}

function shape_quad(m, array) {
  var len = array.length;
  if (Caml_int32.mod_(len, m) > 0) {
    throw [
          DIM,
          "Dimensions do not match!"
        ];
  } else {
    var res = Belt_Array.make(Caml_int32.div(len, m), Belt_Array.make(0, 0));
    var loop = function (_cur_idx) {
      while(true) {
        var cur_idx = _cur_idx;
        if (cur_idx > (len - m | 0)) {
          return /* () */0;
        } else {
          var new_row = Belt_Array.slice(array, cur_idx, m);
          Belt_Array.setExn(res, Caml_int32.div(cur_idx, m), new_row);
          _cur_idx = cur_idx + m | 0;
          continue ;
        }
      };
    };
    loop(0);
    return res;
  }
}

function has_at_least_n_stones(array, n) {
  return Belt_Array.reduce(array, 0, (function (acc, value) {
                if (value === 1) {
                  return acc + 1 | 0;
                } else {
                  return acc;
                }
              })) >= n;
}

function generate_pattern($staropt$star, size, max_stones) {
  var min_stones = $staropt$star !== undefined ? $staropt$star : 0;
  var rows = generate_row_permutations(size, max_stones);
  var loop = function (_cur_rows, _res) {
    while(true) {
      var res = _res;
      var cur_rows = _cur_rows;
      if (cur_rows === size) {
        return res;
      } else {
        var new_res = Belt_List.flatten(Belt_List.map(res, (function (matrix) {
                    return append_matrix(matrix, rows);
                  })));
        _res = new_res;
        _cur_rows = cur_rows + 1 | 0;
        continue ;
      }
    };
  };
  return Belt_List.map(Belt_List.keep(filter_dups_from_list(loop(1, rows)), (function (array) {
                    return has_at_least_n_stones(array, min_stones);
                  })), (function (matrix) {
                return shape_quad(size, matrix);
              }));
}

function write_deck(deck, dest) {
  Fs.writeFileSync(dest, deck, "ascii");
  return /* () */0;
}

function get_unsafe(matrix, x_ind, y_ind) {
  return Belt_Array.getExn(Belt_Array.getExn(matrix, y_ind), x_ind);
}

function set_unsafe(matrix, x_ind, y_ind, value) {
  return Belt_Array.setExn(Belt_Array.getExn(matrix, y_ind), x_ind, value);
}

function rot90_square(matrix) {
  var dim = matrix.length;
  var rotated = Belt_Array.map(Belt_Array.make(dim, -1), (function (param) {
          return Belt_Array.make(dim, param);
        }));
  for(var i = 0 ,i_finish = dim - 1 | 0; i <= i_finish; ++i){
    for(var j = 0 ,j_finish = dim - 1 | 0; j <= j_finish; ++j){
      set_unsafe(rotated, (dim - i | 0) - 1 | 0, j, get_unsafe(matrix, j, i));
    }
  }
  return rotated;
}

function get_array_dim(m1) {
  var m = m1.length;
  var n = Belt_Array.getExn(m1, 0).length;
  return /* tuple */[
          n,
          m
        ];
}

function get_all_rots(m) {
  var m_rot_90 = rot90_square(m);
  var m_rot_180 = rot90_square(m_rot_90);
  var m_rot_270 = rot90_square(m_rot_180);
  return /* :: */[
          m,
          /* :: */[
            m_rot_90,
            /* :: */[
              m_rot_180,
              /* :: */[
                m_rot_270,
                /* [] */0
              ]
            ]
          ]
        ];
}

function cmp_matrix_square(m1, m2) {
  var dim = m1.length;
  var _idx = 0;
  while(true) {
    var idx = _idx;
    if (idx === dim) {
      return 1;
    } else {
      var row_m1 = Belt_Array.getExn(m1, idx);
      var row_m2 = Belt_Array.getExn(m2, idx);
      if (Belt_Array.eq(row_m1, row_m2, Caml_obj.caml_equal)) {
        _idx = idx + 1 | 0;
        continue ;
      } else {
        return -1;
      }
    }
  };
}

function eq_matrix_square(m1, m2) {
  return cmp_matrix_square(m1, m2) === 1;
}

function is_rot_equal(m1, m2) {
  var _matrices = get_all_rots(m2);
  while(true) {
    var matrices = _matrices;
    if (matrices) {
      if (eq_matrix_square(m1, matrices[0])) {
        return true;
      } else {
        _matrices = matrices[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function make_n_m_matrix(n, m) {
  return Belt_Array.map(Belt_Array.make(n, 0), (function (param) {
                return Belt_Array.make(m, param);
              }));
}

function filter_rot_equal(matrices) {
  var not_rot_equal = Belt_List.make(0, make_n_m_matrix(0, 0));
  return Belt_List.reduce(matrices, not_rot_equal, (function (acc, row) {
                if (Belt_List.has(acc, row, is_rot_equal)) {
                  return acc;
                } else {
                  return Belt_List.add(acc, row);
                }
              }));
}

export {
  DIM ,
  generate_one_stone_permutations ,
  filter_dups_from_list ,
  generate_row_permutations ,
  append_matrix ,
  shape_quad ,
  has_at_least_n_stones ,
  generate_pattern ,
  write_deck ,
  get_unsafe ,
  set_unsafe ,
  rot90_square ,
  get_array_dim ,
  get_all_rots ,
  cmp_matrix_square ,
  eq_matrix_square ,
  is_rot_equal ,
  make_n_m_matrix ,
  filter_rot_equal ,
  
}
/* fs Not a pure module */
