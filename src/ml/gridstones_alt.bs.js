// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Curry from "../../node_modules/bs-platform/lib/es6/curry.js";
import * as Phaser from "phaser";
import * as Caml_obj from "../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "../../node_modules/bs-platform/lib/es6/belt_List.js";
import * as Belt_Array from "../../node_modules/bs-platform/lib/es6/belt_Array.js";
import * as Caml_int32 from "../../node_modules/bs-platform/lib/es6/caml_int32.js";
import * as Belt_MapString from "../../node_modules/bs-platform/lib/es6/belt_MapString.js";
import * as Caml_exceptions from "../../node_modules/bs-platform/lib/es6/caml_exceptions.js";

var DIM = Caml_exceptions.create("Gridstones_alt.Generator.DIM");

function generate_one_stone_permutations(row) {
  var fill_copy = function (idx) {
    var row$1 = row.slice(0);
    Belt_Array.setExn(row$1, idx, 1);
    return row$1;
  };
  var loop = function (perm, idx) {
    try {
      var cur_value = Belt_Array.getExn(row, idx);
      if (cur_value !== -1) {
        return loop(perm, idx + 1 | 0);
      } else {
        return loop(Belt_List.add(perm, fill_copy(idx)), idx + 1 | 0);
      }
    }
    catch (exn){
      return perm;
    }
  };
  return loop(Belt_List.make(0, row), 0);
}

function filter_dups_from_list(perm) {
  var no_dup = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(perm, no_dup, (function (acc, row) {
                if (Belt_List.has(acc, row, (function (l1, l2) {
                          return Belt_Array.eq(l1, l2, Caml_obj.caml_equal);
                        }))) {
                  return acc;
                } else {
                  return Belt_List.add(acc, row);
                }
              }));
}

function generate_row_permutations(size, max_stones) {
  var empty_row = Belt_Array.make(size, -1);
  var res = Belt_List.make(1, empty_row);
  var loop = function (_cur_stones, _latest_rows, _res) {
    while(true) {
      var res = _res;
      var latest_rows = _latest_rows;
      var cur_stones = _cur_stones;
      if (cur_stones > max_stones) {
        return res;
      } else {
        var new_rows = Belt_List.flatten(Belt_List.map(latest_rows, generate_one_stone_permutations));
        _res = Belt_List.concat(res, latest_rows);
        _latest_rows = new_rows;
        _cur_stones = cur_stones + 1 | 0;
        continue ;
      }
    };
  };
  return filter_dups_from_list(loop(0, res, Belt_List.make(-1, empty_row)));
}

function append_matrix(matrix, rows) {
  var res = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(rows, res, (function (acc, row) {
                return Belt_List.add(acc, Belt_Array.concat(matrix, row));
              }));
}

function shape_quad(m, array) {
  var len = array.length;
  if (Caml_int32.mod_(len, m) > 0) {
    throw [
          DIM,
          "Dimensions do not match!"
        ];
  } else {
    var res = Belt_Array.make(Caml_int32.div(len, m), Belt_Array.make(0, 0));
    var loop = function (_cur_idx) {
      while(true) {
        var cur_idx = _cur_idx;
        if (cur_idx > (len - m | 0)) {
          return /* () */0;
        } else {
          var new_row = Belt_Array.slice(array, cur_idx, m);
          Belt_Array.setExn(res, Caml_int32.div(cur_idx, m), new_row);
          _cur_idx = cur_idx + m | 0;
          continue ;
        }
      };
    };
    loop(0);
    return res;
  }
}

function has_at_least_n_stones(array, n) {
  return Belt_Array.reduce(array, 0, (function (acc, value) {
                if (value === 1) {
                  return acc + 1 | 0;
                } else {
                  return acc;
                }
              })) >= n;
}

function generate_pattern($staropt$star, size, max_stones) {
  var min_stones = $staropt$star !== undefined ? $staropt$star : 0;
  var rows = generate_row_permutations(size, max_stones);
  var loop = function (_cur_rows, _res) {
    while(true) {
      var res = _res;
      var cur_rows = _cur_rows;
      if (cur_rows === size) {
        return res;
      } else {
        var new_res = Belt_List.flatten(Belt_List.map(res, (function (matrix) {
                    return append_matrix(matrix, rows);
                  })));
        _res = new_res;
        _cur_rows = cur_rows + 1 | 0;
        continue ;
      }
    };
  };
  return Belt_List.map(Belt_List.keep(filter_dups_from_list(loop(1, rows)), (function (array) {
                    return has_at_least_n_stones(array, min_stones);
                  })), (function (matrix) {
                return shape_quad(size, matrix);
              }));
}

function write_deck(deck, dest) {
  Fs.writeFileSync(dest, deck, "ascii");
  return /* () */0;
}

function get_unsafe(matrix, x_ind, y_ind) {
  return Belt_Array.getExn(Belt_Array.getExn(matrix, y_ind), x_ind);
}

function set_unsafe(matrix, x_ind, y_ind, value) {
  return Belt_Array.setExn(Belt_Array.getExn(matrix, y_ind), x_ind, value);
}

function rot90_square(matrix) {
  var dim = matrix.length;
  var rotated = Belt_Array.map(Belt_Array.make(dim, -1), (function (param) {
          return Belt_Array.make(dim, param);
        }));
  for(var i = 0 ,i_finish = dim - 1 | 0; i <= i_finish; ++i){
    for(var j = 0 ,j_finish = dim - 1 | 0; j <= j_finish; ++j){
      set_unsafe(rotated, (dim - i | 0) - 1 | 0, j, get_unsafe(matrix, j, i));
    }
  }
  return rotated;
}

function get_array_dim(m1) {
  var m = m1.length;
  var n = Belt_Array.getExn(m1, 0).length;
  return /* tuple */[
          n,
          m
        ];
}

function get_all_rots(m) {
  var m_rot_90 = rot90_square(m);
  var m_rot_180 = rot90_square(m_rot_90);
  var m_rot_270 = rot90_square(m_rot_180);
  return /* :: */[
          m,
          /* :: */[
            m_rot_90,
            /* :: */[
              m_rot_180,
              /* :: */[
                m_rot_270,
                /* [] */0
              ]
            ]
          ]
        ];
}

function cmp_matrix_square(m1, m2) {
  var dim = m1.length;
  var _idx = 0;
  while(true) {
    var idx = _idx;
    if (idx === dim) {
      return 1;
    } else {
      var row_m1 = Belt_Array.getExn(m1, idx);
      var row_m2 = Belt_Array.getExn(m2, idx);
      if (Belt_Array.eq(row_m1, row_m2, Caml_obj.caml_equal)) {
        _idx = idx + 1 | 0;
        continue ;
      } else {
        return -1;
      }
    }
  };
}

function eq_matrix_square(m1, m2) {
  return cmp_matrix_square(m1, m2) === 1;
}

function is_rot_equal(m1, m2) {
  var _matrices = get_all_rots(m2);
  while(true) {
    var matrices = _matrices;
    if (matrices) {
      if (eq_matrix_square(m1, matrices[0])) {
        return true;
      } else {
        _matrices = matrices[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function make_n_m_matrix(n, m) {
  return Belt_Array.map(Belt_Array.make(n, 0), (function (param) {
                return Belt_Array.make(m, param);
              }));
}

function filter_rot_equal(matrices) {
  var not_rot_equal = Belt_List.make(0, make_n_m_matrix(0, 0));
  return Belt_List.reduce(matrices, not_rot_equal, (function (acc, row) {
                if (Belt_List.has(acc, row, is_rot_equal)) {
                  return acc;
                } else {
                  return Belt_List.add(acc, row);
                }
              }));
}

var Generator = /* module */[
  /* DIM */DIM,
  /* generate_one_stone_permutations */generate_one_stone_permutations,
  /* filter_dups_from_list */filter_dups_from_list,
  /* generate_row_permutations */generate_row_permutations,
  /* append_matrix */append_matrix,
  /* shape_quad */shape_quad,
  /* has_at_least_n_stones */has_at_least_n_stones,
  /* generate_pattern */generate_pattern,
  /* write_deck */write_deck,
  /* get_unsafe */get_unsafe,
  /* set_unsafe */set_unsafe,
  /* rot90_square */rot90_square,
  /* get_array_dim */get_array_dim,
  /* get_all_rots */get_all_rots,
  /* cmp_matrix_square */cmp_matrix_square,
  /* eq_matrix_square */eq_matrix_square,
  /* is_rot_equal */is_rot_equal,
  /* make_n_m_matrix */make_n_m_matrix,
  /* filter_rot_equal */filter_rot_equal
];

function transform_world_to_image_coords(x, y, canvas_width, canvas_height) {
  return /* record */[
          /* x */(canvas_width / 2 | 0) + x | 0,
          /* y */(canvas_height / 2 | 0) + y | 0
        ];
}

function get_n_m_board(n, m) {
  return Belt_Array.map(Belt_Array.make(m, 0), (function (param) {
                return Belt_Array.make(n, param);
              }));
}

function scale_marble_size(board_width, board_height, p) {
  return /* record */[
          /* width */board_width / 6.0 - p,
          /* height */board_height / 6.0 - p
        ];
}

function dot_product(m1, m2) {
  var flattened_m1 = Belt_Array.concatMany(m1);
  var flattened_m2 = Belt_Array.concatMany(m2);
  return Belt_Array.reduce(Belt_Array.zip(flattened_m1, flattened_m2), 0, (function (acc, param) {
                return Caml_int32.imul(param[0], param[1]) + acc | 0;
              }));
}

function sub_matrix(m, $staropt$star, $staropt$star$1, x_len, y_len) {
  var x_offset = $staropt$star !== undefined ? $staropt$star : 0;
  var y_offset = $staropt$star$1 !== undefined ? $staropt$star$1 : 0;
  var extracted_y = Belt_Array.slice(m, y_offset, y_len);
  return Belt_Array.map(extracted_y, (function (row) {
                return Belt_Array.slice(row, x_offset, x_len);
              }));
}

function conv(aoi, filter) {
  var y_size = filter.length;
  var x_size = Belt_Array.getExn(filter, 0).length;
  var y_size_half = (y_size - 1 | 0) / 2 | 0;
  var x_size_half = (x_size - 1 | 0) / 2 | 0;
  return Belt_Array.mapWithIndex(aoi, (function (i, row) {
                return Belt_Array.mapWithIndex(row, (function (j, param) {
                              if ((i - y_size_half | 0) < 0 || (j - x_size_half | 0) < 0) {
                                return 0;
                              } else {
                                return dot_product(sub_matrix(aoi, j - x_size_half | 0, i - y_size_half | 0, x_size, y_size), filter);
                              }
                            }));
              }));
}

var res = Belt_Array.map(Belt_Array.make(6, "42a5f5"), (function (param) {
        return Belt_Array.make(6, param);
      }));

Belt_Array.forEachWithIndex(res, (function (y, rows) {
        return Belt_Array.forEachWithIndex(rows, (function (x, param) {
                      var x$1 = x;
                      var y$1 = y;
                      var set_color = function (value) {
                        return set_unsafe(res, x$1, y$1, value);
                      };
                      var match = x$1 < 5;
                      var match$1 = y$1 < 5;
                      var exit = 0;
                      var exit$1 = 0;
                      if (x$1 !== 0 || !(match && match$1)) {
                        exit$1 = 2;
                      } else {
                        return set_color("fdd835");
                      }
                      if (exit$1 === 2) {
                        if (y$1 !== 0) {
                          if (y$1 !== 5) {
                            exit = 1;
                          } else {
                            return set_color("ff5722");
                          }
                        } else if (match && match$1) {
                          return set_color("fdd835");
                        } else {
                          exit = 1;
                        }
                      }
                      if (exit === 1) {
                        if (x$1 !== 5) {
                          return set_color("42a5f5");
                        } else {
                          return set_color("ff5722");
                        }
                      }
                      
                    }));
      }));

var Utils = /* module */[
  /* transform_world_to_image_coords */transform_world_to_image_coords,
  /* get_n_m_board */get_n_m_board,
  /* scale_marble_size */scale_marble_size,
  /* dot_product */dot_product,
  /* sub_matrix */sub_matrix,
  /* conv */conv,
  /* color_map */res
];

function has_match(board_state, pattern) {
  var num_stones = Belt_Array.reduce(Belt_Array.concatMany(pattern), 0, (function (acc, slot) {
          if (slot === 1) {
            return acc + 1 | 0;
          } else {
            return acc;
          }
        }));
  return Belt_Array.some(Belt_Array.concatMany(conv(board_state, pattern)), (function (e) {
                return e === num_stones;
              }));
}

function matches_any_rot(board_state, pattern) {
  var matches_cur_board = function (p) {
    return has_match(board_state, p);
  };
  return Belt_List.some(Belt_List.map(get_all_rots(pattern), matches_cur_board), (function (isMatch) {
                return isMatch;
              }));
}

function matches_any_pattern(board_state, patterns) {
  return Belt_Array.keep(Belt_Array.mapWithIndex(patterns, (function (i, pattern) {
                    return /* tuple */[
                            i,
                            matches_any_rot(board_state, pattern)
                          ];
                  })), (function (param) {
                return param[1];
              }));
}

function modify_slot(board_state, position, state) {
  var set_cur_board = function (x, y, value) {
    return set_unsafe(board_state, x, y, value);
  };
  switch (state) {
    case 0 : 
        set_cur_board(position[/* x */0], position[/* y */1], 1);
        return /* NEW */2;
    case 1 : 
        set_cur_board(position[/* x */0], position[/* y */1], 0);
        return /* EMPTY */0;
    case 2 : 
        return /* NEW */2;
    case 3 : 
        return /* LOCKED */3;
    
  }
}

var scene = new Phaser.Scene({
      key: "board"
    });

var gameObjectFactory = scene.add;

function draw_board($staropt$star, $staropt$star$1, w, h) {
  var x_offset = $staropt$star !== undefined ? $staropt$star : 0.0;
  var y_offset = $staropt$star$1 !== undefined ? $staropt$star$1 : 0.0;
  var board_container = gameObjectFactory.container();
  var s_width = w / 6.0;
  var s_height = w / 6.0;
  for(var i = 0; i <= 6; ++i){
    for(var j = 0; j <= 6; ++j){
      var slot = gameObjectFactory.graphics();
      var fillColor = parseInt(get_unsafe(res, j, i), 16);
      var s_x = j * s_width;
      var s_y = i * s_height;
      var hit_zone = gameObjectFactory.zone(/* tuple */[
            s_x + 0.5 * s_width,
            s_y + 0.5 * s_height,
            s_width,
            s_height
          ]);
      slot.lineStyle(/* tuple */[
            5,
            1.0
          ]);
      var param = /* tuple */[
        fillColor,
        1.0
      ];
      slot.fillStyllE(param);
      slot.beginPath();
      if (i === 0) {
        var param$1 = /* tuple */[
          s_x,
          s_y
        ];
        slot.moveTo(param$1);
        var param_000 = s_x + s_width;
        var param$2 = /* tuple */[
          param_000,
          s_y
        ];
        slot.lineTo(param$2);
      }
      var param_000$1 = s_x + s_width;
      var param$3 = /* tuple */[
        param_000$1,
        s_y
      ];
      slot.moveTo(param$3);
      var param_000$2 = s_x + s_width;
      var param_001 = s_y + s_height;
      var param$4 = /* tuple */[
        param_000$2,
        param_001
      ];
      slot.lineTo(param$4);
      var param_001$1 = s_y + s_height;
      var param$5 = /* tuple */[
        s_x,
        param_001$1
      ];
      slot.lineTo(param$5);
      if (j === 0) {
        var param$6 = /* tuple */[
          s_x,
          s_y
        ];
        slot.lineTo(param$6);
      }
      var param_000$3 = j * s_width;
      var param_001$2 = i * s_height;
      var param$7 = /* tuple */[
        param_000$3,
        param_001$2,
        s_width,
        s_height
      ];
      slot.fillRect(param$7);
      slot.strokePath();
      hit_zone.setInteractive();
      board_container.add(slot);
      board_container.add(hit_zone);
    }
  }
  board_container.setPosition(/* tuple */[
        x_offset,
        y_offset
      ]);
  return /* () */0;
}

var sys = scene.sys;

var board_width = sys[/* canvas */0][/* width */0] * 0.8;

var board_height = sys[/* canvas */0][/* width */0] * 0.8;

var create = draw_board(undefined, undefined, board_width, board_height);

var Board = /* module */[
  /* grid_w */6.0,
  /* grid_h */6.0,
  /* has_match */has_match,
  /* matches_any_rot */matches_any_rot,
  /* matches_any_pattern */matches_any_pattern,
  /* modify_slot */modify_slot,
  /* scene */scene,
  /* gameObjectFactory */gameObjectFactory,
  /* draw_board */draw_board,
  /* create */create
];

function initMap(param) {
  return Belt_MapString.empty;
}

var update_state = Belt_MapString.set;

function dispatch(state, listeners, key, data) {
  var new_state = Belt_MapString.set(state, key, data);
  if (Belt_MapString.has(listeners, key)) {
    Belt_Array.forEach(Belt_MapString.getExn(listeners, key), (function (fn) {
            return Curry._1(fn, new_state);
          }));
  }
  return new_state;
}

function subscribe(listeners, $$event, fn) {
  var new_list;
  try {
    var cur_listeners = Belt_MapString.getExn(listeners, $$event);
    new_list = Belt_Array.concat(cur_listeners, Belt_Array.make(1, fn));
  }
  catch (exn){
    new_list = Belt_Array.make(1, fn);
  }
  var newIndex = new_list.length;
  return /* tuple */[
          Belt_MapString.set(listeners, $$event, new_list),
          newIndex
        ];
}

function unsubscribe(listeners, $$event, idx) {
  try {
    return Belt_MapString.set(listeners, $$event, Belt_Array.keepWithIndex(Belt_MapString.getExn(listeners, $$event), (function (param, i) {
                      return i === idx;
                    })));
  }
  catch (exn){
    return listeners;
  }
}

var get_value = Belt_MapString.getExn;

var State = /* module */[
  /* moveAction */"MOVE",
  /* idAction */"ID",
  /* playersAction */"PLAYERS",
  /* turnAction */"TURN",
  /* gamePhaseAction */"PHASE",
  /* handAction */"HAND",
  /* winnerAction */"WINNER",
  /* initMap */initMap,
  /* update_state */update_state,
  /* dispatch */dispatch,
  /* subscribe */subscribe,
  /* unsubscribe */unsubscribe,
  /* get_value */get_value
];

export {
  Generator ,
  Utils ,
  Board ,
  State ,
  
}
/* res Not a pure module */
